diff --git a/WORKSPACE b/WORKSPACE
index e1c8c9de..6aa77d16 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -77,7 +77,7 @@ stack_snapshot(
     name = "stackage-zlib",
     packages = ["zlib"],
     snapshot = "lts-13.15",
-    deps = ["@zlib.dev//:zlib"],
+    deps = {"zlib": ["@zlib.dev//:zlib"]},
 )
 
 load(
diff --git a/examples/WORKSPACE b/examples/WORKSPACE
index 9bca98c7..4da9e173 100644
--- a/examples/WORKSPACE
+++ b/examples/WORKSPACE
@@ -96,7 +96,7 @@ stack_snapshot(
     ],
     snapshot = "lts-14.0",
     vendored_packages = {"split": "@split//:split"},
-    deps = ["@zlib.dev//:zlib"],
+    deps = {"zlib": ["@zlib.dev//:zlib"]},
 )
 
 # For the rts example.
diff --git a/haskell/cabal.bzl b/haskell/cabal.bzl
index 0c17e937..7f88ed96 100644
--- a/haskell/cabal.bzl
+++ b/haskell/cabal.bzl
@@ -693,6 +693,25 @@ def _invert(d):
     """Invert a dictionary."""
     return dict(zip(d.values(), d.keys()))
 
+def _from_string_keyed_label_list_dict(d):
+    """Convert string_keyed_label_list_dict to label_keyed_string_dict."""
+    out = {}
+    for (string_key, label_list) in d.items():
+        for label in label_list:
+            if label in out:
+                out[label] += " " + string_key
+            else:
+                out[label] = string_key
+    return out
+
+def _to_string_keyed_label_list_dict(d):
+    """Convert label_keyed_string_dict to string_keyed_label_list_dict."""
+    out = {}
+    for (label, string_key_list) in d.items():
+        for string_key in string_key_list.split(" "):
+            out.setdefault(string_key, []).append(label)
+    return out
+
 def _label_to_string(label):
     return "@{}//{}:{}".format(label.workspace_name, label.package, label.name)
 
@@ -731,7 +750,7 @@ def _stack_snapshot_impl(repository_ctx):
         vendored_packages,
     )
 
-    extra_deps = [_label_to_string(label) for label in repository_ctx.attr.deps]
+    extra_deps = _to_string_keyed_label_list_dict(repository_ctx.attr.deps)
     tools = [_label_to_string(label) for label in repository_ctx.attr.tools]
 
     # Write out dependency graph as importable Starlark value.
@@ -803,7 +822,10 @@ haskell_cabal_library(
                     version = package.version,
                     flags = package.flags,
                     dir = package.sdist,
-                    deps = package.deps + extra_deps,
+                    deps = package.deps + [
+                        _label_to_string(label)
+                        for label in extra_deps.get(package.name, [])
+                    ],
                     tools = tools,
                     visibility = visibility,
                 ),
@@ -827,7 +849,7 @@ _stack_snapshot = repository_rule(
         "packages": attr.string_list(),
         "vendored_packages": attr.label_keyed_string_dict(),
         "flags": attr.string_list_dict(),
-        "deps": attr.label_list(),
+        "deps": attr.label_keyed_string_dict(),
         "tools": attr.label_list(),
         "stack": attr.label(),
     },
@@ -891,7 +913,7 @@ _fetch_stack = repository_rule(
 )
 """Find a suitably recent local Stack or download it."""
 
-def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
+def stack_snapshot(stack = None, vendored_packages = {}, deps = {}, **kwargs):
     """Use Stack to download and extract Cabal source distributions.
 
     Args:
@@ -904,7 +926,7 @@ def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
         unpacked source distribution. Each package must contain a Cabal file
         named `<package-name>.cabal` in the package root.
       flags: A dict from package name to list of flags.
-      deps: Dependencies of the package set, e.g. system libraries or C/C++ libraries.
+      deps: Extra dependencies of packages, e.g. system libraries or C/C++ libraries.
       tools: Tool dependencies. They are built using the host configuration, since
         the tools are executed as part of the build.
       stack: The stack binary to use to enumerate package dependencies.
@@ -918,7 +940,7 @@ def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
           vendored_packages = {"split": "//split:split"},
           tools = ["@happy//:happy", "@c2hs//:c2hs"],
           snapshot = "lts-13.15",
-          deps = ["@zlib.dev//:zlib"],
+          deps = {"zlib": ["@zlib.dev//:zlib"]},
       )
       ```
       defines `@stackage//:conduit`, `@stackage//:lens`,
@@ -932,7 +954,7 @@ def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
           flags = {"zlib": ["-non-blocking-ffi"]},
           tools = ["@happy//:happy", "@c2hs//:c2hs"],
           local_Snapshot = "//:snapshot.yaml",
-          deps = ["@zlib.dev//:zlib"],
+          deps = {"zlib": ["@zlib.dev//:zlib"]},
       ```
       Does the same as the previous example, provided there is a
       `snapshot.yaml`, at the root of the repository with content
@@ -969,6 +991,9 @@ def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
         stack = Label("@rules_haskell_stack//:stack")
     _stack_snapshot(
         stack = stack,
+        # TODO Remove _from_string_keyed_label_list_dict once following issue
+        # is resolved: https://github.com/bazelbuild/bazel/issues/7989.
+        deps = _from_string_keyed_label_list_dict(deps),
         # TODO Remove _invert once following issue is resolved:
         # https://github.com/bazelbuild/bazel/issues/7989.
         vendored_packages = _invert(vendored_packages),
diff --git a/haskell/private/cabal_wrapper.sh.tpl b/haskell/private/cabal_wrapper.sh.tpl
index c0a97bb7..322f4af7 100644
--- a/haskell/private/cabal_wrapper.sh.tpl
+++ b/haskell/private/cabal_wrapper.sh.tpl
@@ -31,14 +31,37 @@ function canonicalize_path()
     new_path=""
     while IFS=: read -r -d: entry
     do
-	if [[ -n "$entry" ]]
-	then
-	    new_path="$new_path${new_path:+:}$(realpath "$entry")"
-	fi
+        if [[ -n "$entry" ]]
+        then
+            new_path="$new_path${new_path:+:}$(realpath "$entry")"
+        fi
     done <<< "${1:-}:"
     echo $new_path
 }
 
+# relative_to ORIGIN PATH
+# Compute the relative path from ORIGIN to PATH.
+function relative_to() {
+    local out=
+    # Split path into components
+    local -a relto; IFS="/\\" read -ra relto <<<"$1"
+    local -a path; IFS="/\\" read -ra path <<<"$2"
+    local off=0
+    while [[ "${relto[$off]}" == "${path[$off]}" ]]; do
+        if [[ $off -eq ${#relto[@]} || $off -eq ${#path[@]} ]]; then
+            break
+        fi
+        : $((off++))
+    done
+    for ((i=$off; i < ${#relto[@]}; i++)); do
+        out="$out${out:+/}.."
+    done
+    for ((i=$off; i < ${#path[@]}; i++)); do
+        out="$out${out:+/}${path[$i]}"
+    done
+    echo "$out"
+}
+
 # Remove any relative entries, because we'll be changing CWD shortly.
 LD_LIBRARY_PATH=$(canonicalize_path $LD_LIBRARY_PATH)
 LIBRARY_PATH=$(canonicalize_path $LIBRARY_PATH)
@@ -48,7 +71,7 @@ name=$1
 execroot="$(pwd)"
 setup=$execroot/$2
 srcdir=$execroot/$3
-pkgroot="$(realpath $execroot/$4/..)" # By definition (see ghc-pkg source code).
+pkgroot="$(realpath $execroot/$(dirname $4))" # By definition (see ghc-pkg source code).
 shift 4
 
 declare -a extra_args
@@ -113,8 +136,23 @@ library=($libdir/libHS*.a)
 if [[ -n ${library+x} ]]
 then
     mv $libdir/libHS*.a $dynlibdir
-    sed 's,library-dirs:.*,library-dirs: ${pkgroot}/lib,' \
-	$package_database/$name.conf > $package_database/$name.conf.tmp
+    # The $execroot is an absolute path and should not leak into the output.
+    # Replace each ocurrence of execroot by a path relative to ${pkgroot}.
+    function replace_execroot() {
+        local line
+        local relpath
+        while IFS="" read -r line; do
+            while [[ $line =~ ("$execroot"[^[:space:]]*) ]]; do
+                relpath="$(relative_to "$pkgroot" "${BASH_REMATCH[1]}")"
+                line="${line/${BASH_REMATCH[1]}/\$\{pkgroot\}\/$relpath/}"
+            done
+            echo "$line"
+        done
+    }
+    sed -e 's,library-dirs:.*,library-dirs: ${pkgroot}/lib,' \
+        $package_database/$name.conf \
+        | replace_execroot \
+        > $package_database/$name.conf.tmp
     mv  $package_database/$name.conf.tmp $package_database/$name.conf
     %{ghc_pkg} recache --package-db=$package_database
 fi
