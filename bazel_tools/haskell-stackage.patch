diff --git a/WORKSPACE b/WORKSPACE
index e1c8c9de..6aa77d16 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -77,7 +77,7 @@ stack_snapshot(
     name = "stackage-zlib",
     packages = ["zlib"],
     snapshot = "lts-13.15",
-    deps = ["@zlib.dev//:zlib"],
+    deps = {"zlib": ["@zlib.dev//:zlib"]},
 )
 
 load(
diff --git a/examples/WORKSPACE b/examples/WORKSPACE
index 9bca98c7..4da9e173 100644
--- a/examples/WORKSPACE
+++ b/examples/WORKSPACE
@@ -96,7 +96,7 @@ stack_snapshot(
     ],
     snapshot = "lts-14.0",
     vendored_packages = {"split": "@split//:split"},
-    deps = ["@zlib.dev//:zlib"],
+    deps = {"zlib": ["@zlib.dev//:zlib"]},
 )
 
 # For the rts example.
diff --git a/haskell/BUILD.bazel b/haskell/BUILD.bazel
index 266a023d..b1b91916 100644
--- a/haskell/BUILD.bazel
+++ b/haskell/BUILD.bazel
@@ -39,6 +39,12 @@ sh_binary(
     visibility = ["//visibility:public"],
 )
 
+sh_binary(
+    name = "ghc_wrapper_dbg",
+    srcs = ["private/ghc_wrapper_dbg.sh"],
+    visibility = ["//visibility:public"],
+)
+
 py_binary(
     name = "version_macros",
     srcs = ["private/version_macros.py"],
diff --git a/haskell/cabal.bzl b/haskell/cabal.bzl
index 0c17e937..34eabcbf 100644
--- a/haskell/cabal.bzl
+++ b/haskell/cabal.bzl
@@ -70,6 +70,7 @@ main = defaultMain
     return setup
 
 _CABAL_TOOLS = ["alex", "c2hs", "cpphs", "doctest", "happy"]
+_CABAL_TOOL_LIBRARIES = ["cpphs", "doctest"]
 
 # Some old packages are empty compatibility shims. Empty packages
 # cause Cabal to not produce the outputs it normally produces. Instead
@@ -635,7 +636,7 @@ def _compute_dependency_graph(repository_ctx, snapshot, core_packages, versioned
     indirect_unpacked_sdists = []
     for package in exec_result.stdout.splitlines():
         name = _chop_version(package)
-        if name in _CABAL_TOOLS:
+        if name in _CABAL_TOOLS and not name in _CABAL_TOOL_LIBRARIES:
             continue
 
         version = _version(package)
@@ -693,6 +694,25 @@ def _invert(d):
     """Invert a dictionary."""
     return dict(zip(d.values(), d.keys()))
 
+def _from_string_keyed_label_list_dict(d):
+    """Convert string_keyed_label_list_dict to label_keyed_string_dict."""
+    out = {}
+    for (string_key, label_list) in d.items():
+        for label in label_list:
+            if label in out:
+                out[label] += " " + string_key
+            else:
+                out[label] = string_key
+    return out
+
+def _to_string_keyed_label_list_dict(d):
+    """Convert label_keyed_string_dict to string_keyed_label_list_dict."""
+    out = {}
+    for (label, string_key_list) in d.items():
+        for string_key in string_key_list.split(" "):
+            out.setdefault(string_key, []).append(label)
+    return out
+
 def _label_to_string(label):
     return "@{}//{}:{}".format(label.workspace_name, label.package, label.name)
 
@@ -731,7 +751,7 @@ def _stack_snapshot_impl(repository_ctx):
         vendored_packages,
     )
 
-    extra_deps = [_label_to_string(label) for label in repository_ctx.attr.deps]
+    extra_deps = _to_string_keyed_label_list_dict(repository_ctx.attr.deps)
     tools = [_label_to_string(label) for label in repository_ctx.attr.tools]
 
     # Write out dependency graph as importable Starlark value.
@@ -803,7 +823,10 @@ haskell_cabal_library(
                     version = package.version,
                     flags = package.flags,
                     dir = package.sdist,
-                    deps = package.deps + extra_deps,
+                    deps = package.deps + [
+                        _label_to_string(label)
+                        for label in extra_deps.get(package.name, [])
+                    ],
                     tools = tools,
                     visibility = visibility,
                 ),
@@ -827,7 +850,7 @@ _stack_snapshot = repository_rule(
         "packages": attr.string_list(),
         "vendored_packages": attr.label_keyed_string_dict(),
         "flags": attr.string_list_dict(),
-        "deps": attr.label_list(),
+        "deps": attr.label_keyed_string_dict(),
         "tools": attr.label_list(),
         "stack": attr.label(),
     },
@@ -891,7 +914,7 @@ _fetch_stack = repository_rule(
 )
 """Find a suitably recent local Stack or download it."""
 
-def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
+def stack_snapshot(stack = None, vendored_packages = {}, deps = {}, **kwargs):
     """Use Stack to download and extract Cabal source distributions.
 
     Args:
@@ -904,7 +927,7 @@ def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
         unpacked source distribution. Each package must contain a Cabal file
         named `<package-name>.cabal` in the package root.
       flags: A dict from package name to list of flags.
-      deps: Dependencies of the package set, e.g. system libraries or C/C++ libraries.
+      deps: Extra dependencies of packages, e.g. system libraries or C/C++ libraries.
       tools: Tool dependencies. They are built using the host configuration, since
         the tools are executed as part of the build.
       stack: The stack binary to use to enumerate package dependencies.
@@ -918,7 +941,7 @@ def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
           vendored_packages = {"split": "//split:split"},
           tools = ["@happy//:happy", "@c2hs//:c2hs"],
           snapshot = "lts-13.15",
-          deps = ["@zlib.dev//:zlib"],
+          deps = {"zlib": ["@zlib.dev//:zlib"]},
       )
       ```
       defines `@stackage//:conduit`, `@stackage//:lens`,
@@ -932,7 +955,7 @@ def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
           flags = {"zlib": ["-non-blocking-ffi"]},
           tools = ["@happy//:happy", "@c2hs//:c2hs"],
           local_Snapshot = "//:snapshot.yaml",
-          deps = ["@zlib.dev//:zlib"],
+          deps = {"zlib": ["@zlib.dev//:zlib"]},
       ```
       Does the same as the previous example, provided there is a
       `snapshot.yaml`, at the root of the repository with content
@@ -969,6 +992,9 @@ def stack_snapshot(stack = None, vendored_packages = {}, **kwargs):
         stack = Label("@rules_haskell_stack//:stack")
     _stack_snapshot(
         stack = stack,
+        # TODO Remove _from_string_keyed_label_list_dict once following issue
+        # is resolved: https://github.com/bazelbuild/bazel/issues/7989.
+        deps = _from_string_keyed_label_list_dict(deps),
         # TODO Remove _invert once following issue is resolved:
         # https://github.com/bazelbuild/bazel/issues/7989.
         vendored_packages = _invert(vendored_packages),
diff --git a/haskell/defs.bzl b/haskell/defs.bzl
index 61c931ca..b1e3a4d0 100644
--- a/haskell/defs.bzl
+++ b/haskell/defs.bzl
@@ -91,6 +91,11 @@ _haskell_common_attrs = {
         cfg = "host",
         default = Label("@rules_haskell//haskell:ghc_wrapper"),
     ),
+    "_ghc_wrapper_dbg": attr.label(
+        executable = True,
+        cfg = "host",
+        default = Label("@rules_haskell//haskell:ghc_wrapper_dbg"),
+    ),
 }
 
 def _mk_binary_rule(**kwargs):
diff --git a/haskell/private/context.bzl b/haskell/private/context.bzl
index 9d5f2b4c..052f9757 100644
--- a/haskell/private/context.bzl
+++ b/haskell/private/context.bzl
@@ -37,7 +37,9 @@ def haskell_context(ctx, attr = None):
         coverage_enabled = ctx.configuration.coverage_enabled
 
     ghc_wrapper = None
-    if hasattr(ctx.executable, "_ghc_wrapper"):
+    if ctx.label.name.startswith("damlc") and hasattr(ctx.executable, "_ghc_wrapper_dbg"):
+        ghc_wrapper = ctx.executable._ghc_wrapper_dbg
+    elif hasattr(ctx.executable, "_ghc_wrapper"):
         ghc_wrapper = ctx.executable._ghc_wrapper
 
     return HaskellContext(
diff --git a/haskell/private/ghc_wrapper_dbg.sh b/haskell/private/ghc_wrapper_dbg.sh
new file mode 100755
index 00000000..08679aaa
--- /dev/null
+++ b/haskell/private/ghc_wrapper_dbg.sh
@@ -0,0 +1,19 @@
+#!/usr/bin/env bash
+set -ueo pipefail
+export PATH=${PATH:-} # otherwise GCC fails on Windows
+
+# this is equivalent to 'readarray'. We do not use 'readarray' in order to
+# support older bash versions.
+while IFS= read -r line; do compile_flags+=("$line"); done < $1
+
+# Detect if we are in the persistent worker mode
+if [ "$2" == "--persistent_worker" ]; then
+    compile_flags=("${compile_flags[@]:1}")  # remove ghc executable
+    # This is a proof-of-concept implementation, not ready for production usage:
+    # it assumes https://github.com/tweag/bazel-worker/ installed globally as ~/bin/worker
+    exec ~/bin/worker ${compile_flags[@]} --persistent_worker
+else
+    while IFS= read -r line; do extra_args+=("$line"); done < "$2"
+    "${compile_flags[@]}" "${extra_args[@]}" 2>&1 \
+      | while IFS= read -r line; do [[ $line =~ ^Loaded ]] || echo "$line"; done >&2
+fi
